<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probability Lab: List 4</title>
    
    <!-- MathJax -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            /* Dark Theme Palette */
            --primary: #10b981; /* Emerald/Green for List 4 */
            --primary-hover: #059669;
            --bg: #111827; 
            --card-bg: #1f2937; 
            --text: #f3f4f6; 
            --text-muted: #9ca3af;
            --border: #374151;
            --canvas-bg: #111827;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #3b82f6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        header {
            background: #111827;
            border-bottom: 1px solid var(--border);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { margin: 0; font-size: 1.5rem; color: var(--text); }
        p.subtitle { margin: 5px 0 0; color: var(--text-muted); font-size: 0.9rem; }

        .lang-switch {
            display: flex;
            gap: 5px;
            background: var(--border);
            padding: 4px;
            border-radius: 6px;
        }
        
        .lang-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: bold;
        }
        .lang-btn.active { background: var(--primary); color: white; }

        .tabs {
            display: flex;
            background: #111827;
            border-bottom: 1px solid var(--border);
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-muted);
            transition: all 0.2s;
            border: none;
            background: none;
            border-bottom: 3px solid transparent;
        }
        .tab:hover { color: var(--text); background-color: rgba(255,255,255,0.05); }
        .tab.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
            background-color: var(--card-bg);
        }

        .section { display: none; padding: 20px; animation: fadeIn 0.3s ease-in-out; }
        .section.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
        }

        button.action-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }
        button.action-btn:hover { background-color: var(--primary-hover); }
        button.secondary { background-color: var(--border); color: var(--text); }
        button.secondary:hover { background-color: #4b5563; }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            position: relative;
        }
        canvas {
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--canvas-bg);
            max-width: 100%;
        }

        .description {
            margin-bottom: 20px;
            line-height: 1.6;
            color: var(--text);
            background: rgba(16, 185, 129, 0.1); /* Green tint */
            padding: 15px;
            border-left: 4px solid var(--primary);
            border-radius: 4px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .stat-box {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid var(--border);
        }
        .stat-val { font-size: 1.2rem; font-weight: bold; color: var(--primary); font-family: monospace; }
        .stat-lbl { font-size: 0.8rem; color: var(--text-muted); }

        /* Sliders */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        input[type=range] {
            accent-color: var(--primary);
        }

    </style>
</head>
<body>

<div class="container">
    <header>
        <div class="header-content">
            <h1 data-key="title">Selected Distributions Lab</h1>
            <p class="subtitle" data-key="subtitle">List 4: Binomial, Geometric, and Normal Distributions</p>
        </div>
        <div class="lang-switch">
            <button class="lang-btn active" onclick="setLanguage('en')">EN</button>
            <button class="lang-btn" onclick="setLanguage('pl')">PL</button>
        </div>
    </header>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('binomial')" data-key="tabBinomial">1. Binomial (Quality Control)</button>
        <button class="tab" onclick="switchTab('geometric')" data-key="tabGeometric">2. Geometric (The Shooter)</button>
        <button class="tab" onclick="switchTab('normal')" data-key="tabNormal">3. Normal (Sugar Factory)</button>
    </div>

    <!-- MODULE 1: BINOMIAL -->
    <div id="binomial" class="section active">
        <div class="description" data-key="descBinomial">
            <strong>Task 1:</strong> Production quality. We check a batch of $N$ items. Each has probability $p$ of being defective.
            <br>This models the <strong>Binomial Distribution</strong> $B(n, p)$.
            <br>Experiment: Generate batches and count defects. See how the histogram changes with $p$.
        </div>

        <div class="controls">
            <div class="slider-group">
                <label>N (Sample Size): <span id="valN">10</span></label>
                <input type="range" id="sliderN" min="5" max="50" value="10" oninput="updateBinomialParams()">
            </div>
            <div class="slider-group">
                <label>p (Defect Rate): <span id="valP">0.05</span></label>
                <input type="range" id="sliderP" min="0.01" max="0.99" step="0.01" value="0.05" oninput="updateBinomialParams()">
            </div>
            <button class="action-btn" onclick="runBinomialBatch()" data-key="btnCheckBatch">Check Batch</button>
            <button class="action-btn" onclick="runBinomialFast()" data-key="btnSim1000">Simulate 1000x</button>
            <button class="action-btn secondary" onclick="resetBinomial()" data-key="btnReset">Reset</button>
        </div>

        <div class="canvas-container">
            <canvas id="binomialCanvas" width="600" height="350"></canvas>
        </div>
        
        <div class="stats-grid">
            <div class="stat-box">
                <div id="binomAvg" class="stat-val">0.00</div>
                <div class="stat-lbl" data-key="statAvgDefects">Avg Defects (Empirical)</div>
            </div>
            <div class="stat-box">
                <div id="binomTheory" class="stat-val">0.00</div>
                <div class="stat-lbl" data-key="statTheoryExp">Expected Value $E(X)=np$</div>
            </div>
        </div>
    </div>

    <!-- MODULE 2: GEOMETRIC -->
    <div id="geometric" class="section">
        <div class="description" data-key="descGeometric">
            <strong>Task 4:</strong> Shooting until the first hit. Probability of hit $p=0.2$ (hard) to $p=0.8$ (easy).
            <br>This models the <strong>Geometric Distribution</strong>.
            <br>Question: How many shots $k$ are needed? (Success at $k$-th trial).
        </div>

        <div class="controls">
            <div class="slider-group">
                <label>Hit Chance (p): <span id="valGeoP">0.3</span></label>
                <input type="range" id="sliderGeoP" min="0.1" max="0.9" step="0.1" value="0.3" oninput="updateGeoParams()">
            </div>
            <button class="action-btn" onclick="shootOnce()" data-key="btnShoot">Shoot Until Hit!</button>
            <button class="action-btn" onclick="shootFast()" data-key="btnSim1000">Simulate 1000x</button>
            <button class="action-btn secondary" onclick="resetGeo()" data-key="btnReset">Reset</button>
        </div>

        <div class="canvas-container">
            <canvas id="geoCanvas" width="600" height="350"></canvas>
        </div>

        <div class="stats-grid">
            <div class="stat-box">
                <div id="geoAvg" class="stat-val">0.00</div>
                <div class="stat-lbl" data-key="statAvgShots">Avg Shots Needed</div>
            </div>
            <div class="stat-box">
                <div id="geoTheory" class="stat-val">0.00</div>
                <div class="stat-lbl" data-key="statTheoryGeo">Theory $E(X)=1/p$</div>
            </div>
        </div>
    </div>

    <!-- MODULE 3: NORMAL -->
    <div id="normal" class="section">
        <div class="description" data-key="descNormal">
            <strong>Task 9:</strong> Sugar Factory. Target weight $\mu = 1000$g. Deviation $\sigma$.
            <br>This models the <strong>Normal Distribution</strong> (Gaussian).
            <br>Observe how individual bags (random noise) form the Bell Curve over time (Central Limit Theorem in action).
        </div>

        <div class="controls">
            <div class="slider-group">
                <label>Sigma ($\sigma$): <span id="valSigma">20</span></label>
                <input type="range" id="sliderSigma" min="5" max="50" step="5" value="20" oninput="resetNormal()">
            </div>
            <button class="action-btn" onclick="dropBags(1)" data-key="btnFill1">Fill 1 Bag</button>
            <button class="action-btn" onclick="dropBags(100)" data-key="btnFill100">Fill 100 Bags</button>
            <button class="action-btn secondary" onclick="resetNormal()" data-key="btnReset">Reset Line</button>
        </div>

        <div class="canvas-container">
            <canvas id="normalCanvas" width="600" height="350"></canvas>
        </div>

        <div class="stats-grid">
            <div class="stat-box">
                <div id="normCount" class="stat-val">0</div>
                <div class="stat-lbl" data-key="statBags">Bags Filled</div>
            </div>
            <div class="stat-box">
                <div id="normInRange" class="stat-val">0%</div>
                <div class="stat-lbl" data-key="statInSigma">In Range $\mu \pm \sigma$ (Theory: 68%)</div>
            </div>
        </div>
    </div>

</div>

<script>
    // --- TRANSLATIONS ---
    const translations = {
        en: {
            title: "Selected Distributions Lab",
            subtitle: "List 4: Binomial, Geometric, and Normal Distributions",
            tabBinomial: "1. Binomial (Quality Control)",
            tabGeometric: "2. Geometric (The Shooter)",
            tabNormal: "3. Normal (Sugar Factory)",
            // Binomial
            descBinomial: "<strong>Task 1:</strong> Production quality. We check a batch of $N$ items. Each has probability $p$ of being defective. <br>This models the <strong>Binomial Distribution</strong> $B(n, p)$. <br>Experiment: Generate batches and count defects. See how the histogram changes with $p$.",
            btnCheckBatch: "Check Batch",
            btnSim1000: "Simulate 1000x",
            btnReset: "Reset",
            statAvgDefects: "Avg Defects (Empirical)",
            statTheoryExp: "Expected Value $E(X)=np$",
            // Geometric
            descGeometric: "<strong>Task 4:</strong> Shooting until the first hit. Probability of hit $p$. <br>This models the <strong>Geometric Distribution</strong>. <br>Question: How many shots $k$ are needed? (Success at $k$-th trial).",
            btnShoot: "Shoot Until Hit!",
            statAvgShots: "Avg Shots Needed",
            statTheoryGeo: "Theory $E(X)=1/p$",
            // Normal
            descNormal: "<strong>Task 9:</strong> Sugar Factory. Target weight $\\mu = 1000$g. Deviation $\\sigma$. <br>This models the <strong>Normal Distribution</strong> (Gaussian). <br>Observe how individual bags (random noise) form the Bell Curve over time.",
            btnFill1: "Fill 1 Bag",
            btnFill100: "Fill 100 Bags",
            statBags: "Bags Filled",
            statInSigma: "In Range $\\mu \\pm \\sigma$ (Theory: 68%)",
            // Canvas Labels
            lblDefects: "Number of Defects",
            lblFreq: "Frequency",
            lblAttempts: "Attempts to Hit",
            lblWeight: "Weight (g)"
        },
        pl: {
            title: "Laboratorium Rozkładów",
            subtitle: "Lista 4: Rozkład Dwumianowy, Geometryczny i Normalny",
            tabBinomial: "1. Dwumianowy (Kontrola Jakości)",
            tabGeometric: "2. Geometryczny (Strzelec)",
            tabNormal: "3. Normalny (Fabryka Cukru)",
            // Binomial
            descBinomial: "<strong>Zadanie 1:</strong> Jakość produkcji. Badamy partię $N$ elementów. Każdy ma szansę $p$ bycia wadliwym. <br>Modeluje to <strong>Rozkład Dwumianowy</strong> $B(n, p)$. <br>Eksperyment: Generuj partie i licz defekty. Zobacz jak histogram zmienia się z $p$.",
            btnCheckBatch: "Sprawdź Partię",
            btnSim1000: "Symuluj 1000x",
            btnReset: "Resetuj",
            statAvgDefects: "Śr. liczba defektów (Empir.)",
            statTheoryExp: "Wartość Oczekiwana $E(X)=np$",
            // Geometric
            descGeometric: "<strong>Zadanie 4:</strong> Strzelanie do pierwszego trafienia. P-stwo trafienia $p$. <br>Modeluje to <strong>Rozkład Geometryczny</strong>. <br>Pytanie: Ile strzałów $k$ potrzeba? (Sukces w $k$-tej próbie).",
            btnShoot: "Strzelaj do trafienia!",
            statAvgShots: "Śr. liczba strzałów",
            statTheoryGeo: "Teoria $E(X)=1/p$",
            // Normal
            descNormal: "<strong>Zadanie 9:</strong> Fabryka Cukru. Waga docelowa $\\mu = 1000$g. Odchylenie $\\sigma$. <br>Modeluje to <strong>Rozkład Normalny</strong> (Gaussa). <br>Obserwuj jak pojedyncze worki (szum losowy) tworzą Krzywą Dzwonową.",
            btnFill1: "Napełnij 1 Worek",
            btnFill100: "Napełnij 100 Worków",
            statBags: "Worków",
            statInSigma: "W zakresie $\\mu \\pm \\sigma$ (Teoria: 68%)",
            // Canvas
            lblDefects: "Liczba Defektów",
            lblFreq: "Częstość",
            lblAttempts: "Próby do trafienia",
            lblWeight: "Waga (g)"
        }
    };

    let currentLang = 'en';
    function setLanguage(lang) {
        currentLang = lang;
        const t = translations[lang];
        document.querySelectorAll('[data-key]').forEach(el => {
            const key = el.getAttribute('data-key');
            if(t[key]) el.innerHTML = t[key];
        });
        document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
        const activeBtnIndex = lang === 'en' ? 0 : 1;
        document.querySelectorAll('.lang-btn')[activeBtnIndex].classList.add('active');

        if (window.MathJax && window.MathJax.typesetPromise) window.MathJax.typesetPromise();

        // Redraw
        if(document.getElementById('binomial').classList.contains('active')) drawBinomial();
        if(document.getElementById('geometric').classList.contains('active')) drawGeometric();
        if(document.getElementById('normal').classList.contains('active')) drawNormal();
    }

    function switchTab(tabId) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        
        const tabs = ['binomial', 'geometric', 'normal'];
        document.querySelectorAll('.tab')[tabs.indexOf(tabId)].classList.add('active');
        document.getElementById(tabId).classList.add('active');

        if(tabId === 'binomial') drawBinomial();
        if(tabId === 'geometric') drawGeometric();
        if(tabId === 'normal') drawNormal();
    }

    // --- MODULE 1: BINOMIAL ---
    let binN = 10;
    let binP = 0.05;
    let binHistory = []; // Stores counts of defects per batch
    let lastBatch = [];  // Visuals of last batch (0=OK, 1=Defect)

    function updateBinomialParams() {
        binN = parseInt(document.getElementById('sliderN').value);
        binP = parseFloat(document.getElementById('sliderP').value);
        document.getElementById('valN').textContent = binN;
        document.getElementById('valP').textContent = binP.toFixed(2);
        resetBinomial();
    }

    function resetBinomial() {
        binHistory = [];
        lastBatch = [];
        drawBinomial();
    }

    function runBinomialBatch() {
        // Generate one batch
        let defects = 0;
        lastBatch = [];
        for(let i=0; i<binN; i++) {
            const isDefect = Math.random() < binP;
            if(isDefect) defects++;
            lastBatch.push(isDefect);
        }
        binHistory.push(defects);
        drawBinomial();
    }

    function runBinomialFast() {
        for(let k=0; k<1000; k++) {
            let defects = 0;
            for(let i=0; i<binN; i++) {
                if(Math.random() < binP) defects++;
            }
            binHistory.push(defects);
        }
        // Don't visualize last batch dots for fast mode to save performance/logic
        lastBatch = []; 
        drawBinomial();
    }

    function drawBinomial() {
        const canvas = document.getElementById('binomialCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const t = translations[currentLang];

        ctx.clearRect(0,0,w,h);

        // 1. Draw Last Batch Visualization (Top)
        const vizH = 80;
        ctx.fillStyle = "#374151";
        ctx.fillRect(10, 10, w-20, vizH);
        
        if(lastBatch.length > 0) {
            const dotSize = Math.min(20, (w-40)/binN - 5);
            const startX = (w - (dotSize+5)*binN)/2;
            
            lastBatch.forEach((isDefect, i) => {
                ctx.beginPath();
                ctx.arc(startX + i*(dotSize+5) + dotSize/2, 10 + vizH/2, dotSize/2, 0, Math.PI*2);
                ctx.fillStyle = isDefect ? "#ef4444" : "#10b981";
                ctx.fill();
            });
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            const k = lastBatch.filter(x=>x).length;
            ctx.fillText(`${k} Defects / ${binN} Items`, w/2, 10 + vizH - 5);
        } else {
            ctx.fillStyle = "#9ca3af";
            ctx.textAlign = "center";
            ctx.fillText("Click 'Check Batch' to visualize samples", w/2, 10 + vizH/2);
        }

        // 2. Histogram (Bottom)
        const histTop = vizH + 40;
        const histH = h - histTop - 30;
        
        // Count frequencies
        const counts = new Array(binN+1).fill(0);
        let maxCount = 0;
        let sumDefects = 0;

        binHistory.forEach(k => {
            counts[k]++;
            if(counts[k] > maxCount) maxCount = counts[k];
            sumDefects += k;
        });

        // Draw axis
        ctx.strokeStyle = "#4b5563";
        ctx.beginPath(); ctx.moveTo(40, h-20); ctx.lineTo(w-20, h-20); ctx.stroke();

        // Draw bars
        const barW = (w - 60) / (binN + 1);
        counts.forEach((count, k) => {
            if(count === 0) return;
            const barH = (count / maxCount) * histH;
            const x = 40 + k*barW;
            const y = h - 20 - barH;
            
            ctx.fillStyle = "#3b82f6";
            ctx.fillRect(x+1, y, barW-2, barH);
        });

        // Stats Update
        const avg = binHistory.length > 0 ? sumDefects / binHistory.length : 0;
        document.getElementById('binomAvg').textContent = avg.toFixed(2);
        document.getElementById('binomTheory').textContent = (binN * binP).toFixed(2);
        
        // Labels
        ctx.fillStyle = "#9ca3af";
        ctx.fillText(t.lblDefects, w/2, h - 5);
    }


    // --- MODULE 2: GEOMETRIC ---
    let geoP = 0.3;
    let geoHistory = []; // Shots needed
    let lastShotsVisual = []; // sequence of misses and hit

    function updateGeoParams() {
        geoP = parseFloat(document.getElementById('sliderGeoP').value);
        document.getElementById('valGeoP').textContent = geoP.toFixed(1);
        resetGeo();
    }

    function resetGeo() {
        geoHistory = [];
        lastShotsVisual = [];
        drawGeometric();
    }

    function shootOnce() {
        let attempts = 0;
        lastShotsVisual = [];
        while(true) {
            attempts++;
            const hit = Math.random() < geoP;
            lastShotsVisual.push(hit);
            if(hit) break;
            // Cap visual at 20 to prevent infinite freeze on low P
            if(attempts > 50) break; 
        }
        geoHistory.push(attempts);
        drawGeometric();
    }

    function shootFast() {
        for(let i=0; i<1000; i++) {
            let attempts = 1;
            while(Math.random() >= geoP) attempts++;
            geoHistory.push(attempts);
        }
        lastShotsVisual = [];
        drawGeometric();
    }

    function drawGeometric() {
        const canvas = document.getElementById('geoCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const t = translations[currentLang];

        ctx.clearRect(0,0,w,h);

        // 1. Visual of sequence (Top)
        const vizH = 60;
        if(lastShotsVisual.length > 0) {
            const dotSize = 10;
            const startX = 20;
            let x = startX;
            let y = 30;
            
            lastShotsVisual.forEach((hit, i) => {
                ctx.beginPath();
                if(hit) {
                    // Star or big circle
                    ctx.arc(x, y, 8, 0, Math.PI*2);
                    ctx.fillStyle = "#10b981"; // Green Hit
                } else {
                    ctx.arc(x, y, 4, 0, Math.PI*2);
                    ctx.fillStyle = "#ef4444"; // Red Miss
                }
                ctx.fill();
                x += 15;
                if(x > w-20) { x = startX; y += 20; }
            });
        }

        // 2. Histogram (Bottom)
        const histTop = 100;
        const histH = h - histTop - 30;
        
        // Geometric tail is infinite, we cut off at max observed or 20
        let maxK = 0;
        let sumK = 0;
        const counts = {}; // Use dict as index can be high

        geoHistory.forEach(k => {
            if(k > maxK) maxK = k;
            counts[k] = (counts[k] || 0) + 1;
            sumK += k;
        });

        // Limit display to 20 or maxK
        const displayMax = Math.min(Math.max(15, maxK), 30);
        let maxFreq = 0;
        for(let k in counts) if(counts[k] > maxFreq) maxFreq = counts[k];

        const barW = (w - 60) / displayMax;

        ctx.strokeStyle = "#4b5563";
        ctx.beginPath(); ctx.moveTo(40, h-20); ctx.lineTo(w-20, h-20); ctx.stroke();

        for(let k=1; k<=displayMax; k++) {
            const count = counts[k] || 0;
            if(count > 0) {
                const barH = (count / maxFreq) * histH;
                const x = 40 + (k-1)*barW;
                const y = h - 20 - barH;
                
                ctx.fillStyle = "#8b5cf6"; // Violet
                ctx.fillRect(x+2, y, barW-4, barH);
                
                // Label x axis occasionally
                if(displayMax < 20 || k % 5 === 0) {
                    ctx.fillStyle = "#fff";
                    ctx.textAlign = "center";
                    ctx.font = "10px sans-serif";
                    ctx.fillText(k, x + barW/2, h - 5);
                }
            }
        }

        // Stats
        const avg = geoHistory.length > 0 ? sumK / geoHistory.length : 0;
        document.getElementById('geoAvg').textContent = avg.toFixed(2);
        document.getElementById('geoTheory').textContent = (1/geoP).toFixed(2);
    }


    // --- MODULE 3: NORMAL ---
    let normMu = 1000;
    let normSigma = 20;
    let normHistory = [];

    function resetNormal() {
        normSigma = parseInt(document.getElementById('sliderSigma').value);
        document.getElementById('valSigma').textContent = normSigma;
        normHistory = [];
        drawNormal();
    }

    function dropBags(n) {
        for(let i=0; i<n; i++) {
            // Box-Muller transform for Normal Dist
            const u1 = Math.random();
            const u2 = Math.random();
            const z = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            const val = normMu + z * normSigma;
            normHistory.push(val);
        }
        drawNormal();
    }

    function drawNormal() {
        const canvas = document.getElementById('normalCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const t = translations[currentLang];

        ctx.clearRect(0,0,w,h);

        // Fixed range for visualization: 900 to 1100 (since mu=1000, max sigma=50 => 3sigma=150 => 850-1150 cover)
        // Let's focus on 920 to 1080
        const minX = 920;
        const maxX = 1080;
        const scaleX = w / (maxX - minX);

        // Bins
        const binSize = 2; // 2g bins
        const numBins = (maxX - minX) / binSize;
        const bins = new Array(numBins).fill(0);
        let maxBin = 0;

        normHistory.forEach(val => {
            if(val >= minX && val < maxX) {
                const idx = Math.floor((val - minX) / binSize);
                bins[idx]++;
                if(bins[idx] > maxBin) maxBin = bins[idx];
            }
        });

        // Draw Histogram
        const histH = h - 50;
        const barW = scaleX * binSize;

        bins.forEach((count, i) => {
            if(count === 0) return;
            const barH = maxBin > 0 ? (count / maxBin) * histH : 0;
            const x = i * barW;
            const y = h - 20 - barH;
            
            // Color based on sigma regions
            const binVal = minX + i*binSize;
            const dist = Math.abs(binVal - normMu);
            
            if(dist < normSigma) ctx.fillStyle = "#10b981"; // 1 sigma (Green)
            else if(dist < 2*normSigma) ctx.fillStyle = "#f59e0b"; // 2 sigma (Orange)
            else ctx.fillStyle = "#ef4444"; // 3 sigma+ (Red)

            ctx.fillRect(x, y, barW+0.5, barH); // +0.5 to fix gaps
        });

        // Draw Center Line
        const centerX = (normMu - minX) * scaleX;
        ctx.strokeStyle = "#fff";
        ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(centerX, 0); ctx.lineTo(centerX, h-20); ctx.stroke();
        ctx.setLineDash([]);

        // Draw 1 Sigma Lines
        const sigmaL = (normMu - normSigma - minX) * scaleX;
        const sigmaR = (normMu + normSigma - minX) * scaleX;
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.beginPath(); ctx.moveTo(sigmaL, h-20); ctx.lineTo(sigmaL, h-40); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(sigmaR, h-20); ctx.lineTo(sigmaR, h-40); ctx.stroke();
        
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText("μ", centerX, h - 5);
        ctx.fillText("-σ", sigmaL, h - 5);
        ctx.fillText("+σ", sigmaR, h - 5);

        // Stats
        const inRange = normHistory.filter(v => Math.abs(v - normMu) <= normSigma).length;
        const pct = normHistory.length > 0 ? (inRange / normHistory.length * 100) : 0;
        
        document.getElementById('normCount').textContent = normHistory.length;
        document.getElementById('normInRange').textContent = pct.toFixed(1) + "%";
    }

    // Init
    setLanguage('en');

</script>

</body>
</html>